use pitch_perfecter::audio::MonoAudio;
use pitch_perfecter::pitch_tracking::detection_algorithms::yin::ExternalYinDetector;
use pitch_perfecter::pitch_tracking::detection::MonoPitchDetector;
use pitch_perfecter::voice_synth::voice_like_single_pitch;
use pitch_perfecter::signal::cleaning::{clean_audio_for_pitch, estimate_noise_spectrum};
use rand::Rng;

/// Generate brown noise (Brownian motion noise) with 1/fÂ² power spectrum
/// Brown noise has decreasing power at higher frequencies, making it more realistic than white noise
fn generate_brown_noise(length: usize, amplitude: f32, rng: &mut impl Rng) -> Vec<f32> {
    let mut brown_noise = Vec::with_capacity(length);
    let mut last_value = 0.0f32;
    
    for _ in 0..length {
        // Brown noise is generated by integrating white noise (cumulative sum with damping)
        let white_sample = amplitude * 0.1 * (rng.random::<f32>() - 0.5);
        last_value = 0.996 * last_value + white_sample; // High-pass filter to prevent DC buildup
        brown_noise.push(last_value);
    }
    
    brown_noise
}

/// Integration test that demonstrates the effectiveness of signal cleaning for pitch detection.
/// 
/// This test creates a noisy signal where pitch detection fails, then applies signal cleaning
/// to recover the ability to detect the correct pitch. It shows the integration between:
/// - Voice synthesis (creating test signals)
/// - YIN pitch detection algorithm
/// - Signal cleaning functionality
/// 
/// Test flow:
/// 1. Generate a clean voice-like signal at a target frequency (220 Hz)
/// 2. Add significant white noise to make pitch detection fail
/// 3. Verify that YIN detector fails on the noisy signal
/// 4. Apply signal cleaning to the noisy signal
/// 5. Verify that YIN detector succeeds on the cleaned signal
#[test]
fn test_pitch_detection_with_signal_cleaning_integration() {
    // Test configuration
    let target_freq = 220.0; // A3 note
    let sample_rate = 8000;
    let window_size = 2048;
    let duration_samples = window_size; // Make sure we have enough samples for the window

    // Generate a clean voice-like signal at target frequency
    let clean_signal = voice_like_single_pitch(target_freq, 3, sample_rate as f32, duration_samples);
    
    // Add significant white noise to make pitch detection fail
    let mut rng = rand::rng();
    let noise_amplitude = 2.0; // Very high noise level to ensure detection failure
    let noisy_signal: Vec<f32> = clean_signal
        .iter()
        .map(|&sample| sample + noise_amplitude * (rng.random::<f32>() - 0.5))
        .collect();

    let noisy_audio = MonoAudio::new(noisy_signal, sample_rate);

    // Test 1: Pitch detection on noisy signal should fail or be inaccurate
    let mut yin_detector = ExternalYinDetector::new(0.1, 0.7, window_size, window_size / 2);
    let noisy_pitch_result = yin_detector.get_mono_pitch(noisy_audio.clone());
    
    // Check if detection was accurate by examining the frequency if present
    let noisy_detection_accurate = match &noisy_pitch_result {
        Some(pitch) => (pitch.frequency - target_freq).abs() < 20.0,
        None => false,
    };
    
    assert!(!noisy_detection_accurate, 
        "Noisy signal pitch detection: frequency = {:?}, accurate = {}", 
        noisy_pitch_result.as_ref().map(|p| p.frequency), noisy_detection_accurate);
    
    // Test 2: Apply signal cleaning and try again
    let cleaned_audio = clean_audio_for_pitch(&noisy_audio, None, None);
    
    // Create a new detector for the cleaned signal test
    let cleaned_pitch_result = yin_detector.get_mono_pitch(cleaned_audio);

    // Should detect accurately after cleaning
    let cleaned_detection_accurate = match &cleaned_pitch_result {
        Some(pitch) => (pitch.frequency - target_freq).abs() < 20.0,
        None => false,
    };
    
    println!("Cleaned signal pitch detection: frequency = {:?}, accurate = {}", 
        cleaned_pitch_result.as_ref().map(|p| p.frequency), cleaned_detection_accurate);
    
    // The key assertion: cleaning should enable accurate detection when noisy signal fails
    assert!(cleaned_detection_accurate, 
        "Signal cleaning should enable accurate pitch detection. Target: {:.1} Hz, Cleaned frequency: {:?}", 
        target_freq, cleaned_pitch_result.as_ref().map(|p| p.frequency));
}

/// Integration test that demonstrates spectral gating for pitch detection.
/// 
/// This test creates a signal with 2 seconds of pure noise followed by a noisy voice signal,
/// then uses the initial noise period to estimate a noise spectrum for spectral gating.
/// It shows the integration between:
/// - Voice synthesis (creating test signals)
/// - Noise spectrum estimation
/// - Spectral gating noise reduction
/// - YIN pitch detection algorithm
/// 
/// Test flow:
/// 1. Generate 2 seconds of pure noise for noise spectrum estimation
/// 2. Generate a voice-like signal at target frequency with added noise
/// 3. Combine noise period + noisy voice signal
/// 4. Estimate noise spectrum from the initial noise period
/// 5. Apply spectral gating using the estimated noise spectrum
/// 6. Verify that YIN detector succeeds on the spectrally-gated signal
#[test]
fn test_pitch_detection_with_spectral_gating_integration() {
    // Test configuration
    let target_freq = 220.0; // A3 note
    let sample_rate = 8000;
    let window_size = 2048; // YIN window size
    let voice_duration_samples = window_size;
    let noise_duration_samples = 2 * sample_rate as usize; // 2 seconds of noise

    // Generate 2 seconds of brown noise at the beginning for noise spectrum estimation
    let mut rng = rand::rng();
    let noise_amplitude = 2.0; // Moderate noise level for brown noise
    let pure_brown_noise = generate_brown_noise(noise_duration_samples, noise_amplitude, &mut rng);
    
    // Generate a clean voice-like signal at target frequency
    let clean_voice_signal = voice_like_single_pitch(target_freq, 3, sample_rate as f32, voice_duration_samples);
    
    // Add brown noise to the voice signal (same characteristics as the pure noise)
    let voice_signal_noise = generate_brown_noise(voice_duration_samples, noise_amplitude, &mut rng);
    let noisy_voice_signal: Vec<f32> = clean_voice_signal
        .iter()
        .zip(voice_signal_noise.iter())
        .map(|(&clean_sample, &noise_sample)| clean_sample + noise_sample)
        .collect();
    
    // Combine: 2 seconds of pure brown noise + noisy voice signal
    let mut combined_signal = pure_brown_noise;
    combined_signal.extend(noisy_voice_signal);
    
    let full_audio = MonoAudio::new(combined_signal, sample_rate as u32);
    
    // Extract just the voice portion for testing pitch detection
    let voice_start_idx = noise_duration_samples;
    let voice_end_idx = voice_start_idx + voice_duration_samples;
    let voice_only_signal = full_audio.samples[voice_start_idx..voice_end_idx].to_vec();
    let voice_only_audio = MonoAudio::new(voice_only_signal, sample_rate as u32);

    // Test 1: Verify that pitch detection fails on the noisy voice signal without cleaning
    let mut yin_detector = ExternalYinDetector::new(0.1, 0.7, window_size, window_size / 2);
    let noisy_pitch_result = yin_detector.get_mono_pitch(voice_only_audio.clone());

    let noisy_detection_accurate = match &noisy_pitch_result {
        Some(pitch) => (pitch.frequency - target_freq).abs() < 20.0,
        None => false,
    };
    
    println!("Noisy voice signal (with brown noise) pitch detection: frequency = {:?}, accurate = {}", 
        noisy_pitch_result.as_ref().map(|p| p.frequency), noisy_detection_accurate);
    
    // Test 2: Estimate noise spectrum from the full audio (which includes the brown noise period)
    let estimated_noise_spectrum = estimate_noise_spectrum(&full_audio);
    assert!(estimated_noise_spectrum.is_some(), "Should be able to estimate noise spectrum from initial brown noise period");
    
    println!("Successfully estimated brown noise spectrum from initial 2-second period");
    
    // Test 3: Apply spectral gating using the estimated brown noise spectrum
    let spectrally_gated_audio = clean_audio_for_pitch(&voice_only_audio, estimated_noise_spectrum, None);
    
    // Test 4: Verify that pitch detection succeeds after spectral gating
    let mut clean_yin_detector = ExternalYinDetector::new(0.1, 0.7, window_size, window_size / 2);
    let gated_pitch_result = clean_yin_detector.get_mono_pitch(spectrally_gated_audio);
    
    let gated_detection_accurate = match &gated_pitch_result {
        Some(pitch) => (pitch.frequency - target_freq).abs() < 20.0,
        None => false,
    };
    
    println!("Spectrally-gated signal (brown noise removed) pitch detection: frequency = {:?}, accurate = {}", 
        gated_pitch_result.as_ref().map(|p| p.frequency), gated_detection_accurate);
    
    // The key assertion: spectral gating should enable accurate detection
    assert!(gated_detection_accurate, 
        "Spectral gating should enable accurate pitch detection. Target: {:.1} Hz, Gated frequency: {:?}", 
        target_freq, gated_pitch_result.as_ref().map(|p| p.frequency));
}